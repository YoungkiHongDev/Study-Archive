# 웹 프로그래밍 변화 과정
1. HTML - 웹 프로그래밍의 시작, 정적인 화면을 구현할 수 있음
2. Servlet - 데이터를 동적으로 가져오기 위한 환경을 구성하기 위해 Java 진영에서 사용, Java 안에서 HTML 사용
3. JSP - 서블릿에서 벗어난 Java 개발자들이 좋아했음, HTML 안에서 Java 사용, HTML과 Java 코드 구분이 힘들어짐, 코드가 외부로 유출되어 보안 문제가 생김, Spring Boot에서는 JSP 사용을 피하는 것을 권장하여 JSP를 Servlet으로 변환시켜주는 tomcat jasper 같은 dependency를 따로 제공하지 않아 수작업으로 넣어야 한다.
4. MVC 패턴 - Front와 Backend를 분리, JSP를 Front로 분리하고 Servlet을 Backend로 사용함, controller/service/vo가 개발자마다 다른 문제가 생김
5. MVC FrameWork - 이전의 Java 웹 개발의 문제점들을 해결하기 위해 Spring 프레임워크가 만들어졌고, Spring 설정의 불편함을 해소하기 위해 Spring Boot가 만들어졌다.


# Servlet
Servlet은 자바 언어로 작성된 웹 어플리케이션을 위한 클래스로 웹 서버에서 실행되어 HTTP 요청에 대한 응답을 생성한다.

주로 웹 프레임워크에서 사용되며, Servlet의 주요 기능은 HTTP 요청 처리, 데이터 처리, 비즈니스 로직 처리, 동적 웹 페이지 생성이 있으며, 이를 통해 클라이언트와 상호작용하고 동적 컨텐츠를 생성할 수 있다.


# JSP/Thymeleaf
Spring Boot의 공식 문서를 보면 JSP에 한계가 있다고 설명한다.
Jar로 실행될 때 JSP는 실행할 수 없다고 한다.

템플릿 엔진에 대한 내용에서는 스프링부트가 자동으로 지원하는 템플릿 엔진에 FreeMarker, Groovy, Thymeleaf, Velocity가 포함되어 있지만 JSP는 빠져있으며, JSP는 제한이 있다고 설명하고 있다.

Spring initializr에서도 Dependencies에 JSP가 나오지 않아서 JSP를 서블릿으로 변환해주는 tomcat jasper를 수동으로 넣어줘야 한다.

JSP에는 문제점이 있는데, JSP를 사용하면 JSP에서 커넥션을 만들어서 DB에 접근할 수 있으므로 보안상의 취약점이 생길 수 있다.

그렇다면 Thymeleaf만 공부하면 되는 것 아닐까? 라고 생각할 수 있지만 국내에 이미 만들어져있는 프로젝트들은 JSP를 사용한 경우가 많아서 JSP 또한 공부할 필요가 있다.


# JSP 보안 취약점
JSP를 사용해서 직접 DB와 커넥션을 만들고 상호작용하면 보안 취약점이 생길 수 있다. 이러한 보안 취약점은 주로 SQL Injection 공격에 노출된다.

SQL Injection 공격은 악의적인 사용자가 입력 값으로 악의적인 SQL 코드를 삽입하여 데이터베이스에 대한 무단 액세스 또는 조작을 시도하는 공격이다.

JSP의 보안 취약점을 해결하기 위한 방법은 다음과 같다.

1. Prepared Statements
Prepared Statements는 SQL 쿼리의 보안을 강화하기 위한 기능이다. 주로 JDBC를 통해 DB에 액세스하는 Java 어플리케이션에서 사용된다. 이 기능은 파라미터 값을 공격자가 SQL로 인식하지 못하게 하여 SQL 인젝션 공격을 방지할 수 있다.

Prepared Statements 작동 방식은 다음과 같다.
- SQL 쿼리 템플릿 설정 : SQL 쿼리 템플릿을 준비하고, 템플릿에 placeholder를 사용한다.
- 파라미터 값 설정 : placeholder 위치에 들어갈 파라미터 값을 세팅한다.
- 파라미터 값 이스케이핑 : DB 드라이버가 파라미터 값과 SQL 쿼리를 준비하고, 파라미터 값이 이스케이핑되어 SQL 인젝션을 방지한다.
- 세팅된 SQL 쿼리를 데이터베이스에 전달 : 안전하게 처리된 SQL 쿼리와 파라미터 값이 데이터베이스에 전달되어 실행된다.

placeholder는 SQL 쿼리에서 값이 들어갈 위치에 '?'와 같은 기호를 임시로 작성해놓은 것을 의미한다. 이것은 파라미터 값의 안전과 SQL 인젝션에 도움된다.

2. ORM 프레임워크
Hibernate, JPA, Mybatis 같은 ORM 프레임워크를 사용하면 데이터베이스 작업을 객체지향 방식으로 수행할 수 있다. ORM 프레임워크는 SQL 인젝션 공격을 방지하기 위한 보안 조치를 자동으로 처리해준다.

3. 데이터베이스 접근 계층 구현
웹 계층과 데이터베이스 계층을 분리하는 방법이다. 웹 계층은 데이터베이스에 직접 액세스하지 않고 데이터베이스 계층과 상호작용한다.

4. 보안 헤더 설정
보안 헤더를 설정하여 웹 보안 공격을 방지할 수 있다.
예를들어, CSP 헤더를 설정하면 XSS 공격을 방지할 수 있다.

XSS 공격은 공격자가 웹 페이지에 악의적인 스크립트를 삽입하여 사용자 브라우저에서 실행되도록 하는 공격 기법이다. 웹 페이지의 보안과 사용자 개인 정보를 위협하는 공격이다.

5. 입력 유효성 검사
사용자가 입력한 데이터를 검증하고 정해진 형식으로 변환하여 데이터의 유효성을 확인하고, 유효하지 않으면 거부하거나 오류 메시지를 제공하여 공격을 방지할 수 있다.

6. 보안 규칙 및 모범 사례 준수
보안 관련된 모범 사례를 따르고, 보안 취약성에 대한 최신 정보를 계속 업데이트하여 보안 규칙을 준수한다.


# Jar/War & 내장톰캣/외장톰캣
프로젝트를 패키징하는 방식에 Jar, War의 2가지 방식이 있다.

**War로 패키징하는 경우**
- View에 JSP를 사용한다.
- 외장 톰캣으로 배포한다.

**Jar로 패키징하는 경우**
- View에 Thymeleaf를 사용한다.
- 내장 톰캣으로 배포한다.

외장 톰캣을 설치해보면 webapp 폴더 아래에 WEB-INF 폴더가 존재한다.
프로젝트에서 JSP를 사용하려면 외장톰캣과 같이 webapp 아래에 WEB-INF를 두게 된다.
또한 War로 패키징하고 내부를 확인해도 같은 구조를 가졌음을 확인할 수 있다.
하지만 Jar로 패키징하면 webapp과 WEB-INF 폴더를 볼 수 없으므로 다른 구조를 가져, 외장톰캣으로 배포를 할 수 없다.


# Lombok 라이브러리
롬복(Lombok)은 자바 프로그래밍 언어를 위한 라이브러리이다. 주로 개발자들이 반복적이고 지루한 작업을 줄이고 간소화하기 위해 사용된다.

롬복은 코드를 자동으로 생성하거나 생성되는 코드를 간소화하는 어노테이션 프로세서 라이브러리이다.

롬복의 이점은 다음과 같다.
1. 반복 코드 제거 : Getter, Setter, 생성자 같은 메소드를 자동 생성한다.
2. 가독성 향상 : 롬복 어노테이션으로 코드 중복을 줄여 가독성이 향상된다.
3. 컴파일 시 코드 생성 : 컴파일 시에 코드를 생성하여 런타임 성능에 영향을 끼치지 않는다.

롬복의 대표적인 어노테이션은 다음과 같다.
1. @Data : 클래스에 대한 @Getter, @Setter, @EqualsAndHashCode, @ToString, @RequiredArgsConstructor 어노테이션을 자동으로 추가한다.
2. @Getter, @Setter : 해당 필드에 대한 Getter, Setter 메소드를 생성한다.
3. @NoArgsConstructor : 파라미터가 없는 기본 생성자를 생성한다.
4. @RequiredArgsConstructor : 필드가 final이거나 @NonNull 어노테이션을 가진 경우 해당 필드를 인자로 받는 생성자를 생성한다.
5. @ToString : toString 메소드를 자동으로 생성하여 객체의 필드를 문자열로 표현한다.
6. @EqualsAndHashCode : equals, hashCode 메소드를 자동으로 생성하여 객체의 동등성을 비교한다.


# DI/IoC
DI -> 의존성 주입  
IoC -> 제어의 역전

Dependency만 있는 구조는 필요할 때마다 객체를 생성한다.
예를들어, Class A가 Class B를 호출할 수 있는 구조가 있다면, 이 경우 A는 B에 의존한다고 할 수 있다.

Dependency와 Injection 모두 있는 구조는 Spring이 Spring Container 안에 있는 객체를 필요로 하는 클래스에 주입한다.
Spring이 구동될 때 @AutoWired 라는 Annotation을 사용한 곳을 찾아 Spring이 객체를 주입한다.
IoC는 이 때 적용되는 개념으로 제어의 주체가 개발자가 아닌 Spring이 된 것을 말한다.

정리하자면, Controller나 Service 같은 Annotation을 쓰면 한 번에 IoC 컨테이너에 들어가고 우리는 그것을 주입 받아서 재사용 할 수 있다. 스프링은 IoC에 객체를 올려놓고 올려진 객체를 재사용한다.


# Spring
Spring은 자바 엔터프라이즈 어플리케이션을 개발하고 관리하기 위한 경량 프레임워크이다.

핵심적인 기능과 구성을 제공하여 개발자가 비즈니스 로직에 집중할 수 있도록 돕는다.

Spring은 IoC와 DI 같은 핵심 개념을 기반으로, 다양한 모듈과 라이브러리를 통해 다양한 엔터프라이즈 서비스를 제공한다.

어플리케이션의 개발, 유지 보수, 확장, 테스트 등 작업을 간편하게 수행할 수 있도록 돕는 엔터프라이즈 솔루션이다.


# Spring Boot
스프링 부트는 스프링 프레임워크를 기반으로 하며, 어플리케이션을 빠르게 개발하고 실행하기 위한 도구이다.

주요 특징으로는 자동 구성, 내장 서버(톰캣, 제티 등), 스타터 패키지, 코드 생성, 설정의 최소화, 간단한 빌드 등이 있다.

스프링 부트를 사용하면 개발자는 복잡한 설정 없이, 어플리케이션의 구조를 빠르게 설정할 수 있으며, 내장 서버를 통해 실행까지 쉽게 처리할 수 있다.

스프링 부트는 다양한 스타터 패키지를 제공하여 필요한 의존성을 간편하게 추가할 수 있고, 커스텀 설정을 통해 어플리케이션을 세밀하게 조정할 수 있다.


# Spring과 Spring Boot의 차이점
Spring은 자바에서 가장 많이 사용되는 프레임워크로, 의존성 주입(DI), 제어의 역전(IoC), 관점 지향 프로그래밍(AOP) 등의 기능을 통해 느슨한 결합을 지원하며, 느슨한 결합을 가진 어플리케이션을 쉽게 테스트할 수 있다.

Spring Boot는 Spring의 다양한 기능을 지원하며, 설정 작접을 간소화하기 위해 개발된 도구로, 자동설정(AutoConfiguration), Spring Boot 스타터를 제공하여 모든 종속성을 호환되는 버전으로 자동 관리한다.


# Containerless
서블릿은 웹 어플리케이션의 핵심적인 웹 컴포넌트 중 하나로 클라이언트의 HTTP 요청을 처리하고 응답을 생성한다.

웹 컴포넌트를 처리하기 위해서는 웹 컨테이너가 필요하다. 웹 컨테이너는 클라이언트의 요청을 받고, 응답을 생성하는 역할을 한다. 이 과정에서 여러 웹 컴포넌트의 라이프사이클 관리와 클라이언트 요청을 적절한 웹 컴포넌트와 연결하는 작업(매핑)을 수행한다.

스프링은 서블릿 컨테이너(웹 컨테이너)에서 작동한다. 스프링은 웹 컴포넌트 역할을 수행하며, 서블릿 컨테이너를 기반으로 동작한다.

스프링은 번거로운 작업을 줄이기 위한 높은 수준의 추상화를 제공하는데, 스프링 컨테이너(스프링 어플리케이션 컨텍스트)를 통해 이러한 작업을 처리한다.

클라이언트의 요청이 들어오면 서블릿 컨테이너가 이를 받아서 스프링 컨테이너로 전달하고, 스프링 컨테이너는 어떤 빈(Bean)이 이 요청을 처리할지 결정하고 해당 빈을 활용하여 클라이언트 요청을 처리한다.

처리 결과는 서블릿 컨테이너를 통해 클라이언트에게 응답된다.

스프링 컨테이너가 서블릿 컨테이너를 완전히 대체하지는 못하며, 서블릿 컨테이너 없이 스프링 어플리케이션을 실행하는 것은 불가능하다.

스프링 부트는 이러한 서블릿 컨테이너 설정을 간소화하여 스프링 부트 스탠드얼론 어플리케이션을 실행할 수 있도록 도와준다. 따라서, 개발자는 서블릿 컨테이너 설정과 관련된 복잡한 작업을 피할 수 있다.

부가적인 설명
- 빈Bean은 스프링 프레임워크에서 관리하는 객체로 요청에 응답하는 컨트롤러 클래스와 같은 역할을 하며, 스프링 컨테이너가 관리한다.
- 스프링 프레임워크는 서블릿 컨테이너 설정을 직접 수행해야 하고, 스프링부트는 서블릿 컨테이너 설정을 대신 수행한다.
- 스프링 부트 스탠드얼론 어플리케이션은 로컬 환경이나, 원하는 환경에서 단독으로 실행하는 응용 프로그램을 말한다.

요약 정리
- 서블릿은 클라이언트 요청과 응답을 처리하는 웹 컴포넌트이다.
- 웹 컴포넌트를 처리하려면 웹 컨테이너(서블릿 컨테이너)가 필요하고, 웹 컨테이너는 웹 컴포넌트의 라이프 사이클 관리화 요청에 맞게 매핑하는 역할을 한다.
- 스프링은 번거로운 웹 컴포넌트 작업을 개선하려고 등장한 프레임워크로, 스프링 컨테이너를 통해 작업을 처리하고 클라이언트 요청을 빈에 매핑하여 처리한다.
- 처리 결과는 서블릿 컨테이너를 통해 클라이언트에게 응답한다.
- 스프링 컨테이너는 서블릿 컨테이너를 대체하지 않고, 서블릿 컨테이너 없이 스프링 어플리케이션을 실행할 수 없으며, 스프링 부트는 서블릿 컨테이너 설정을 간소화하여 스프링 부트 스탠드얼론 어플리케이션을 실행하는 데 도움을 준다.


# Spring Container
스프링 컨테이너는 비즈니스 오브젝트인 POJO와 어플리케이션의 구성정보를 담은 Configuration Metadata를 조합하여 BEAN 오브젝트를 구성하고 서버 어플리케이션으로 만들어준다.

스프링 컨테이너 구현은 다음과 같다.
1. Application Context 생성
2. Application Context에 BEAN 등록
3. 컨테이너 초기화 (초기화 시 등록된 정보로 오브젝트 생성)
4. BEAN 오브젝트 가져오기
5. 바인딩하여 사용하기

스프링 컨테이너는 특정 타입의 오브젝트를 만들어두고 이를 재사용할 수 있도록 지원하며, 이는 싱글톤 패턴을 사용하는 것과 유사하다.


# MVC 패턴
MVC 패턴은 소프트웨어 디자인 패턴 중 하나로, 어플리케이션을 Model, View, Controller 세 가지 컴포넌트로 나누어 개발하는 방법론이다.

이 패턴은 어플리케이션 구조를 더 관리하기 쉽게 만들고, 코드의 가독성과 재사용성을 높이며, 유지보수를 간소화한다.

MVC 패턴의 세 가지 컴포넌트는 다음과 같다.
- 모델 Model : 데이터와 비즈니스 로직을 캡슐화하여 어플리케이션의 핵심 역할을 수행한다.
- 뷰 View : 사용자 인터페이스를 담당하여 모델의 데이터를 표시하고, 사용자와 상호작용한다.
- 컨트롤러 Controller : 사용자 입력을 처리하고 모델의 데이터와 뷰 간의 상호작용을 조정한다.


# Spring MVC
Spring MVC는 MVC 패턴을 구현하고, 웹 어플리케이션을 개발하기 위한 Spring 프레임워크의 일부이다.

웹 어플리케이션의 구조 및 기능을 구조화시키는 데 사용되며, 웹 요청과 응답을 처리하고, MVC 아키텍처를 효과적으로 구현하기 위한 다양한 어노테이션과 클래스를 제공한다.

Spring MVC는 @Controller, @RequestMapping, @ResponseBody 등 여러 어노테이션을 사용하여 웹 요청을 처리하는 컨트롤러 클래스를 정의하고, 뷰를 표현하기 위해 JSP, Thymeleaf, FreeMarker 등 템플릿 엔진을 사용할 수 있다.

Spring MVC를 이용하면 웹 어플리케이션 기능을 논리적으로 분리하고, 개발자가 비즈니스 로직과 사용자 인터페이스를 효과적으로 관리할 수 있다.


# 레이어드 아키텍처
레이어드 아키텍처는 어플리케이션의 컴포넌트를 유사한 것들을 레이어로 묶어서 수평적으로 구성한 구조를 말한다.

아키텍처는 전체 어플리케이션을 나누고, 각 부분을 독립적으로 유지 및 개발하고, 부분들을 조합하여 전체 어플리케이션을 만드는 방식으로 설계된다.

아키텍처는 일반적으로 3계층으로 구성되며, 혹은 인프라 레이어를 추가하여 4계층으로 확장한다.

레이어드 아키텍처는 코드의 모듈화와 유지보수를 용이하게 만들고, 레이어 간의 상호 의존성을 낮추어 어플리케이션을 더 확장 가능하게 만든다.

또한, 코드의 재사용성이 높아지고 각 계층은 독립적으로 테스트할 수 있다.

복잡한 어플리케이션을 관리하고 확장하는 데 도움을 준다.

계층은 다음과 같다.
1. 프레젠테이션 계층  
-> 사용자와의 상호작용을 처리하며, 주로 사용자 인터페이스와 관련된 역할을 한다. 웹 어플리케이션의 경우, 웹 브라우저와 상호작용하고 사용자 요청을 받아들인다.

2. 비즈니스 계층  
-> 어플리케이션의 핵심 로직과 업무 규칙을 다룬다. 데이터 처리, 비즈니스 로직 수행, 데이터 가공 그리고 다양한 업무 규칙을 처리하는 데 사용된다.

3. 데이터 접근 계층  
-> 데이터베이스와 상호작용하여 데이터를 저장, 검색, 업데이트 및 삭제하는 데 사용된다. 이 게층은 데이터베이스와 통신하고 데이터를 읽고 쓰는 작업을 처리한다.

4. 인프라 레이어  
-> 인프라스트럭처 레이어는 특정한 기술 스택과 관련된 부분이다. 예를들어, 데이터베이스 연결, 보안, 메시징 등 인프라스트럭처 관련 작업을 처리한다.


# Servlet과 Spring의 차이점
Servlet은 HTTP 요청과 응답을 처리를 위한 API를 제공하며, 개발자는 스레드 관리, 요청 및 응답처리, 세션 관리 등 세부 작업을 직접 다뤄야 한다. 그래서 개발자가 많은 부분을 처리해야 하는 불편함이 있다.

Spring은 웹 어플리케이션을 빌드하기 위한 프레임워크로, 다양한 기능을 제공하여 개발자의 생산성을 향상시킨다. 그래서 개발자가 세부적이고 반복적인 작업에 시간을 낭비하지 않도록 도와준다.


# JPA
자바 진영의 ORM 표준으로, 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스이다.

JPA 인터페이스를 구현하는 방식에는 Hibernate, EclipseLink, DataNucleus 등이 있지만 Hibernate를 많이 사용한다.

예전에는 JDBC를 사용하여 데이터를 주고 받았으며, 데이터베이스 종류에 따라 다른 JDBC 드라이버를 사용해야 했다.

JPA도 JDBC를 기반으로 동작하지만, JDBC와 각 데이터베이스의 드라이버가 내장되어 있어서 사용중인 데이터베이스에 맞게 설정하여 사용할 수 있다.

따라서, 데이터베이스 간 이식성을 향상시키고 개발을 단순화시킬 수 있다.


# JPA의 장점
1. CRUD 메소드 자동 생성으로 SQL 작성 불필요  
-> JPA가 CRUD 메소드를 자동 생성해주므로 SQL을 직접 작성할 필요가 없다.

2. DB에 맞는 SQL 자동 생성 (방언 지원)  
-> JPA는 데이터베이스 종류에 따라 필요한 SQL을 자동으로 생성으로 생성한다. (이것을 방언이라고 함)

3. Auto DDL로 객체 정의와 테이블 자동 생성  
객체를 정의하고 Auto DDL을 사용하여 테이블을 자동으로 생성할 수 있다.

4. SQL 배치 처리로 성능 향상  
JPA는 여러 SQL 명령을 모아 일괄 처리함으로써 성능을 향상시킬 수 있다.

5. 객체지향 설계 원칙 유지 (Spring과 함께 사용할 경우)  
JPA는 객체지향 프로그래밍의 설계 원칙을 유지하도록 도와주고, Spring과 함께 사용하면 객체지향적 설계를 유지할 수 있다.


# JPA의 단점
1. 객체의 응집력 약화  
-> 엔티티가 데이터베이스와 매핑되는 목적을 가지므로 객체의 응집력이 약화될 수 있다.

2. DTO 필요  
-> JPA를 사용하면 엔티티와 데이터 전송 객체인 DTO를 별도로 정의할 필요가 있다.

3. 의도치 않은 SQL  
-> JPA를 사용하면 의도치 않은 SQL이 실행될 수 있으며, 이를 방지하기 위해 주의가 필요하다.

4. 느린 초기 로딩  
->JPA는 지연 로딩을 사용하여 연관 엔티티를 처음에 가져오지 않고 필요한 시점에 데이터를 로드하는 방식을 취한다. 그래서 초기 엔티티 로딩은 빠르지만 연관 데이터 로딩에 추가적인 쿼리가 필요할 수 있다.

5. 복잡한 쿼리 작성  
-> JPA를 사용하면 복잡한 쿼리를 작성하기 어렵고, 특히 동적 쿼리 또는 복잡한 조인을 처리하는데 어려움을 겪을 수 있다.

6. 오버헤드  
-> JPA를 사용하면 객체와 데이터베이스 사이의 변환 및 매핑 작업이 필요하므로 일정한 오버헤드가 발생하여 성능 저하가 발생할 수 있다.


# Spring Data JPA
Spring Data JPA는 Spring에서 JPA를 편하게 사용할 수 있도록 제공하는 모듈이다.

보일러 플레이트 코드를 최소화하고, CRUD 처리를 위한 공통 인터페이스를 제공하여 개발자가 간단하게 데이터베이스와 상호작용하도록 도와준다.

Spring Data JPA를 사용하려면 JpaRepository 인터페이스를 상속받는 인터페이스를 정의하고, 인터페이스의 메소드를 통해 데이터베이스 조작을 수행할 수 있다.

이 모듈을 사용하면 개발 생산성 향상과 코드의 재사용성을 높여주는 데에 도움을 준다.