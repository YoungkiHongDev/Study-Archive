# 웹 프로그래밍 변화 과정
1. HTML - 웹 프로그래밍의 시작, 정적인 화면을 구현할 수 있음
2. Servlet - 데이터를 동적으로 가져오기 위한 환경을 구성하기 위해 Java 진영에서 사용, Java 안에서 HTML 사용
3. JSP - 서블릿에서 벗어난 Java 개발자들이 좋아했음, HTML 안에서 Java 사용, HTML과 Java 코드 구분이 힘들어짐, 코드가 외부로 유출되어 보안 문제가 생김, Spring Boot에서는 JSP 사용을 피하는 것을 권장하여 JSP를 Servlet으로 변환시켜주는 tomcat jasper 같은 dependency를 따로 제공하지 않아 수작업으로 넣어야 한다.
4. MVC 패턴 - Front와 Backend를 분리, JSP를 Front로 분리하고 Servlet을 Backend로 사용함, controller/service/vo가 개발자마다 다른 문제가 생김
5. MVC FrameWork - 이전의 Java 웹 개발의 문제점들을 해결하기 위해 Spring 프레임워크가 만들어졌고, Spring 설정의 불편함을 해소하기 위해 Spring Boot가 만들어졌다.

# DI/IoC
Dependency만 있는 구조는 필요할 때마다 객체를 생성한다.
예를들어, Class A가 Class B를 호출할 수 있는 구조가 있다면, 이 경우 A는 B에 의존한다고 할 수 있다.

Dependency와 Injection 모두 있는 구조는 Spring이 Spring Container 안에 있는 객체를 필요로 하는 클래스에 주입한다.
Spring이 구동될 때 @AutoWired 라는 Annotation을 사용한 곳을 찾아 Spring이 객체를 주입한다.
IoC는 이 때 적용되는 개념으로 제어의 주체가 개발자가 아닌 Spring이 된 것을 말한다.

# JSP/Thymeleaf
Spring Boot의 공식 문서를 보면 자동으로 지원하는 템플릿 엔진에 FreeMarker, Groovy, Thymeleaf, Velocity가 포함되어 있지만 JSP는 빠져있으며, JSP는 제한이 있다고 설명하고 있다. 그래서 Spring initializr에서도 Dependencies에서 JSP가 나오지 않는다.

JSP에는 문제점이 있는데, JSP를 사용하면 JSP에서 커넥션을 만들어서 DB에 접근할 수 있으므로 보안상의 취약점이 생길 수 있다.
그렇다면 Thymeleaf만 공부하면 되는 것 아닐까? 라고 생각할 수 있지만 국내에 이미 만들어져있는 프로젝트들은 JSP가 사용된 경우가 많아서 JSP 또한 공부할 필요가 있다.

# Jar/War & 내장톰캣/외장톰캣
프로젝트를 패키징하는 방식에 Jar, War의 2가지 방식이 있다.

**War로 패키징하는 경우**
- View에 JSP를 사용한다.
- 외장톰캣으로 배포한다.

**Jar로 패키징하는 경우**
- View에 Thymeleaf를 사용한다.
- 내장톰캣으로 배포한다.

외장톰캣을 설치해보면 webapp 폴더 아래에 WEB-INF 폴더가 존재한다.
프로젝트에서 JSP를 사용하려면 외장톰캣과 같이 webapp 아래에 WEB-INF를 두게 된다.
또한 War로 패키징하고 내부를 확인해도 같은 구조를 가졌음을 확인할 수 있다.
하지만 Jar로 패키징하면 webapp과 WEB-INF 폴더를 볼 수 없으므로 다른 구조를 가져, 외장톰캣으로 배포를 할 수 없다.

# Servlet
Servlet은 자바 언어를 기반으로 웹 어플리케이션을 만들 때 사용하는 자바 클래스다.  
Servlet은 웹 서버에서 실행되며, HTTP 요청에 대한 응답을 생성한다.  
대부분의 웹 프레임워크는 내부적으로 Servlet을 기반으로 동작하며, 이를 활용하여 다양한 기능을 구현할 수 있다.

> 기능 구현 예시

1. 양식 데이터를 처리하여 이메일 전송할 수 있다.
2. 동적 웹 컨텐츠를 생성하기 위해 데이터베이스에서 데이터를 검색하고 웹 페이지에 표시할 수 있다.
3. 세션 관리를 위해 사용자가 로그인하면 새로운 세션을 생성하고, 로그아웃하면 세션을 처리할 수 있다.

> Servlet의 기능

1. HTTP 요청 처리: 클라이언트로부터 HTTP 요청을 받아들이고, 이에 대한 응답을 생성한다.
2. 데이터 처리: 요청된 데이터를 처리하고, 데이터베이스의 데이터를 검색한다.
3. 비즈니스 로직 처리: 요청된 데이터를 기반으로 비즈니스 로직을 실행하고, 결과를 생성한다.
4. 동적인 웹 페이지 생성: Servlet은 HTML, XML, JSON과 같은 동적인 컨텐츠를 생성하여 클라이언트에게 제공한다.

# Spring
자바 엔터프라이즈 개발을 위한 오픈소스 경량 어플리케이션 프레임워크이다.
프레임워크가 인프라 스트럭처를 제공하므로 개발자는 업무로직 개발에만 전념가능하다.
스프링 프레임워크는 공통 프로그래밍 모델 및 Configuration 모델을 제공한다.

# Spring Boot
스프링부트는 스프링을 기반으로 동작하는 애플리케이션을 복잡한 설정 없이 빠르게 작성할 수 있게 도와주는 도구이다.

# Servlet과 Spring의 차이점
Servlet은 HTTP 요청과 응답을 처리하기 위해 기본적인 API를 제공한다. 하지만 개발자가 스레드를 관리하고 요청을 응답처리하고 세션을 관리하는 등 세부 사항들을 직접 처리해야 한다는 불편함이 있다.

Spring은 웹 어플리케이션을 구축하기 위한 다양한 기능을 제공하는 프레임워크이다. 개발에 필요한 작업들을 처리하기 위한 클래스들을 제공해서 개발자의 시간과 노력을 절약할 수 있어서 보다 효율적이고 생산적이다.

# Spring과 Spring Boot의 차이점
Spring은 자바에서 가장 많이 사용하는 프레임워크로 의존성 주입(DI)과 제어의 역전(IoC) 그리고 관점 지향 프로그래밍(AOP)과 같은 요소들을 통해 느슨한 결합을 이룰 수 있으며, 느슨한 결합으로 개발한 어플리케이션은 단위 테스트를 수행하기가 용이하다.

Spring Boot는 Spring에서 다양한 기능을 지원하지만, 그 기능을 사용하기 위한 설정에 개발자들이 많은 시간을 할애하던 단점을 극복하기 위해 나온 프레임워크이다. 자동설정(AutoConfiguration)을 지원하고 SpringBoot-Starter를 제공하여 모든 디펜던시를 호환되는 버전으로 자동 관리해준다.

# MVC 패턴
MVC 패턴은 Model, View, Controller의 세가지 요소로 나누어 어플리케이션을 구성한 패턴을 의미한다. 사용자 인터페이스와 비즈니스 로직을 분리하여 서로 영향이 가지않도록 수정이 가능하다.  

컨트롤러는 모델과 뷰 사이에서 브릿지 역할을 수행하여 사용자의 입력이 들어오면 모델과 뷰를 업데이트한다. 사용자 요청은 모두 컨트롤러를 통하게 해야한다.

뷰는 데이터를 보여주는 화면을 뜻하며, UI 요소들은 뷰에 포함된다. 뷰에는 데이터를 보관하지 않고 컨트롤러에서 데이터를 받아온다.

# 레이어드 아키텍처
레이어드 아키텍처는 어플리케이션의 컴포넌트를 유사한 것들을 레이어로 묶어서 수평적으로 구성한 구조를 말한다. 일반적으로 3계층으로 구성하거나 인프라 레이어를 추가하여 4계층으로 구성한다. 3계층은 프레젠테이션 계층, 비즈니스 계층, 데이터 접근 계층으로 이루어진다.

# Containerless
클라이언트의 요청과 응답을 처리하는 웹 컴포넌트는 웹 컨테이너 안에 있다.  
웹 컨테이너는 여러 웹 컴포넌트의 라이프 사이클 관리, 클라이언트의 요청을 적절한 웹 컴포넌트와 연결시키는 매핑을 해준다.

자바의 컴포넌트는 서블릿이며, 컨테이너는 서블릿 컨테이너이다.  
그리고 서블릿의 한계를 극복하기 위해 나온 것이 스프링 프레임워크이다.  

스프링의 컴포넌트는 BEAN이며, 컨테이너는 스프링 컨테이너라고 불린다.  
스프링 컨테이너는 서블릿 컨테이너의 뒤에 위치한다.  

클라이언트의 요청이 들어오면 서블릿 컨테이너가 받아서 스프링 컨테이너에게 넘겨준다.  
스프링 컨테이너가 어느 BEAN에서 처리할지 정해서 BEAN에게 넘긴다.  
그 후 처리 결과를 서블릿 컨테이너를 통해 클라이언트에게 응답한다.  

하지만 스프링 컨테이너가 서블릿 컨테이너를 대체하지는 못하여 서블릿 컨테이너가 없으면 간단한 애플리케이션도 실행시키지 못한다.  

서블릿 컨테이너 애플리케이션은 개발자가 설정할 것들이 많아서 번거롭다.  
스프링부트는 서블릿 컨테이너를 설정할 필요없이 Stand-alone 애플리케이션을 실행시킬 수 있도록 나온 도구이다.

# Opinionated
스프링은 유연하고 다양한 기술이 있는 Not Opinionated Framework이다.  
이 때문에 개발자들은 선택의 고민이 컸다.  

스프링부트는 Opinionated로 고민보다는 일단 스프링부트 따라서 빠르게 개발할 수 있게한다.  

스프링부트는 커스터마이징을 원하는 개발자들에게 매우 자연스럽고 유연한 방법도 제공한다.

하지만 이것은 스프링부트가 스프링을 어떻게 사용하는지 방식을 이해할 필요가 있고, 그것이 가능하다면 나만의 모듈 또한 작성할 수 있다.

# HTTP
요청과 응답을 하는 방법이 정의되어 있는 프로토콜이다.  
첫 라인의 중요한 정보, Header, Body로 구성된다.

**Request**  
첫 라인이 Method, Path, HTTP 버전으로 구성된다.  
메소드는 GET/POST 등이 있으며, Path는 쿼리스트링으로 Parameter가 올 수 있다.

**Response**  
첫 라인이 HTTP 버전과 상태코드 그리고 상태코드를 간략하게 설명한 Text로 구성된다.  
상태코드가 200이면 정상적인 결과를 출력한다는 의미이고, 400이나 500이면 처리 중 문제가 발생했음을 의미한다.

# Front Controller
모든 서블릿의 공통적인 처리 부분을 앞에서 처리하는 컨트롤러이다.  
대표적인 공통 처리 부분은 인증, 보안, 다국어 처리가 있다.

# 매핑과 바인딩
**매핑**  
웹 요청의 정보에 따라 어떤 컨트롤러가 해당 로직을 수행할지 정해주는 것이다.

**바인딩**  
웹 요청 정보를 코드에서 사용할 수 있도록 데이터를 변환하여 넘겨주는 작업이다.  
예를들어 GET 요청으로 넘어온 파라미터를 추출하여 변수에 넣고 컨트롤러로 넘겨주는 것도 바인딩이라고 볼 수 있다.

# Spring Container
스프링 컨테이너는 비즈니스 오브젝트인 POJO와 애플리케이션의 구성정보를 담은 Configuration Metadata를 조합하여 BEAN 오브젝트를 구성해서 서버 애플리케이션으로 만들어준다.

**스프링 컨테이너 구현**
1. Application Context 생성
2. Application Context에 BEAN 등록
3. 컨테이너 초기화 (초기화 시 등록된 정보로 오브젝트 생성)
4. BEAN 오브젝트 가져오기
5. 바인딩하여 사용하기

스프링 컨테이너는 어떤 타입의 오브젝트를 만들어두면 이것을 계속 재사용할 수 있도록 해준다.  
이것은 마치 싱글톤 패턴을 사용하는 것과 같다.  
그래서 스프링 컨테이너를 싱글톤 레지스트리라고도 부른다.

# Dependency Injection (DI)
Controller, Service 등 2개 이상의 클래스가 있을 때,  
A 클래스가 변경되면 B 클래스가 영향을 받을 경우 두 클래스 사이에 의존 관계가 형성되었다고 할 수 있다.  

다른 Service와 관계를 형성시켜주고 싶다거나 하는 변경이 일어날 때마다 코드를 변경해야하여 불편함이 따른다.  
그래서 여러 클래스들을 인터페이스 하나에 의존하도록 하여 클래스를 변경할 불편함을 줄일 수 있다.  
하지만 실제로는 런타임 시 다른 클래스의 오브젝트를 이용한다.  
인터페이스에 의존하는 어떤 클래스의 오브젝트를 이용하는지 코드상으로는 알 수 없으므로 연관 관계를 만들어 알 수 있게하는 방법이 Dependency Injection이다.

Dependency Injection에는 Assembler가 필요하다.  
Assembler는 의존 관계가 없는 클래스들의 오브젝트를 가져다가 관계를 연결시켜 사용할 수 있도록 만들어주는 역할을 한다.  
이 Assember의 역할을 스프링 컨테이너가 해준다.
스프링 컨테이너는 오브젝트가 사용할 다른 의존 오브젝트가 있다면 그 오브젝트를 주입해주는 작업을 해준다.  

주입을 해준다는 뜻은 오브젝트의 정보를 넘기는 것으로 여러 방법이 있다.  
- 생성자로 주입하는 방법  
- 팩토리 메소드로 주입하는 방법  
- Setter 메소드로 주입하는 방법

# ORM
ORM은 객체 관계 매핑을 뜻한다. ORM 역할은 자바 클래스와 데이터베이스 테이블 매핑한다. node.js에서는 ODM이라고도 한다.

# JPA
자바 진영의 ORM 표준이다. 자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스이다. JPA 인터페이스를 구현하는 방식에는 여러가지가 있다. Hibernate, EclipseLink, DataNucleus 등등이 있지만 Hibernate를 많이 사용한다.

예전에는 JDBC를 이용해 자바 애플리케이션과 DB가 데이터를 주고 받았다. 그리고 DB마다 다른 JDBC 드라이버를 사용하여 SQLite, MySQL, Oracle 등 데이터베이스에 맞춰서 드라이버를 설치하여 사용했다. JPA 또한 JDBC를 사용하는데 JDBC와 각 데이터베이스의 드라이버가 내장되어 있어서 사용하는 데이터베이스에 맞춰 사용할 수 있다.

# JPA의 장점
1. CRUD를 자동 생성하고 실행해 준다. 저장, 조회, 수정, 삭제 시 SQL문을 작성할 필요가 없다.
2. DB에 맞는 SQL을 생성할 수 있다. SQL에는 방언이 있어서 DB에 따라 사용하는 SQL이 다르다. 예를 들면 MySQL이면 Limit을 쓰고, Oracle에서는 rownum을 쓴다. 하지만 JPA를 쓰면 DB를 변경해도 SQL을 바꿀 필요가 없이 JPA 설정만 변경하면 DB에 맞는 SQL이 생성된다. 이것은 JPA에서 제공하는 Dialect라는 추상화된 방언 클래스와 구현체를 제공해서 그렇다.
3. Auto DDL 기능이 있다. 기존에 테이블을 생성하고 객체를 정의하던 것과는 달리 Auto DDL을 사용하면 객체를 정의하고 테이블을 자동 생성한다. 그러면 테이블을 갈아엎을 필요 없이 테이블을 유지하면서 변경사항만 적용시킬 수 있어서 편리하다.
4. SQL을 모아서 한번에 보내서 성능 상 이점이 있다. SQL문은 트랜잭션 구간에서 전송을 하게 되는데 실패하면 롤백을 한다. JPA는 트랜잭션이 끝나기 전까지 SQL을 모아두고 트랜잭션이 끝나는 시점에 한번에 전송을 한다. 그래서 데이터베이스 응용 레벨에서 Repeatable Read 수준의 격리레벨을 제공하는데, 이것은 데이터베이스의 신뢰성을 높이는 것과 같다.
5. JPA의 가장 큰 장점은 객체지향 프로그래밍의 설계 원칙을 지키도록 도운다는 점이다. 데이터베이스에 맞게 프로그래밍을 하면 객체지향을 잃어버릴 수 있는데 JPA가 그러지 않도록 객체지향을 유지시켜준다. 이것은 Spring을 사용하는 이유와 같다.

# JPA의 단점
JPA의 단점은 객체의 응집력을 약화시키는 것이다. 엔티티의 목적은 테이블을 매핑하는 것이라 객체의 성향과 달라서 추가적으로 DTO를 정의해야한다. 또한 JPA를 사용하면 의도치 않은 SQL이 발생할 수도 있다.

# Spring Data JPA
Spring에서 JPA를 편하게 사용할 수 잇도록 제공하는 모듈이다. 보일러 플레이트 코드를 제거하고, CRUD 처리를 위한 공통 인터페이스를 제공한다. 이를 사용하기 위해서 JpaRepository를 상속하는 인터페이스를 정의해야한다.