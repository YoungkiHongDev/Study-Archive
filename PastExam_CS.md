# 자료구조
## Q. Array는 어떤 자료구조인가?
> Array는 데이터를 메모리상에 연속적으로 미리 할당된 크기만큼 저장하는 자료구조이다.

- Array 질문은 Linked List 질문과 연계 될 수 있다. 따라서 메모리 저장 방식과 연산 속도 등 차이점을 알아놓는 것이 좋다.

- Array는 데이터가 메모리에 연속적으로 저장된다.

- 조회 시 메모리에 연속적으로 저장된다는 점을 이용하여 첫번째 데이터의 주소에서 더하기 연산으로 원하는 데이터 주소에 바로 찾아가므로 조회는 O(1)이 걸리며, 이것을 random access라고 한다.

- 삽입/삭제 시 마지막 인덱스라면 O(1), 아니라면 삽입 시에는 요소들을 뒤로 밀고 삭제 시에는 요소들을 앞으로 당겨야하므로 O(n)이 걸린다.

- 탐색 시 일일이 인덱스들을 방문하여 탐색하므로 O(n)이 걸린다.
- Array 장점은 조회에 O(1) 밖에 안걸리므로 조회를 자주 해야할 경우에 유리하다.

- Array 단점은 크기를 미리 정해야하므로 메모리가 낭비될 수 있고, 크기가 부족해서 새로운 Array로 데이터를 이동시키면서 오버헤드가 발생할 수 있다.

## Q. 데이터가 많아서 Array의 size를 넘을 경우 해결방법은?
> size를 예측할 수 있으면 기존보다 size가 더 큰 Array를 만들고 데이터를 옮긴다.  
> size를 예측할 수 없으면 Array 대신 Linked List를 사용하여 데이터가 추가될 때마다 메모리 공간을 할당하여 저장한다.

## Q. Dynamic Array는 어떤 자료구조인가?
> Array는 고정된 size보다 많은 수의 데이터를 저장할 수 없다.  
> 이를 위해 Dynamic Array를 사용할 수 있다.  
> Dynamic Array는 Array의 한계점을 보완한 자료구조이다.  
> 메모리가 초과되면 resize를 통해 데이터를 더 저장할 수 있도록 size를 조절할 수 있어 size를 고민할 필요가 없다는 장점이 있다.  
> resize의 대표적인 방법으로 기존의 2배 size로 조절하는 Doubling이 있다.

- Array의 특징인 고정된 사이즈의 한계점을 보완한 자료구조이다.

- Dynamic Array는 사이즈를 고민할 필요가 없다는 장점이 있다.

- Dynamic Array의 특징으로 첫번째는 resize, 두번째는 Array와 달리 데이터 추가 시 다른 시간복잡도를 가질 수 있다는 점이다.

- Dynamic Array는 resize를 위해 저장공간이 가득 차면 기존의 배열보다 더 큰 배열을 생성하여 데이터를 옮긴다.

- resize의 대표적인 방법인 Doubling은 메모리에 여유가 있을 때 데이터를 추가할 경우 O(1)이지만, 메모리를 초과하면 기존의 2배가 되는 배열을 생성하고 데이터를 일일이 옮기므로 O(n)이 된다.

- 데이터 추가 시 대부분 작업은 O(1), resize할 때만 O(n)이므로 전체적으로 O(1)이라고 할 수 있다.

## Q. Dynamic Array와 Linked List를 비교한 장단점은?
> Linked List와 비교하여 Dynamic Array의 장점은 데이터에 접근 시 random access를 이용하므로 O(1)의 시간복잡도를 가지고, 맨 뒤에 데이터를 추가하거나 삭제할 때도 O(1)의 시간복잡도를 가져서 Linked List에 비해 속도가 빠르다.  
> 하지만, 앞이나 중간에 데이터를 추가하면 연속적으로 저장된 데이터를 뒤로 한칸씩 옮겨야하므로 O(n)의 시간복잡도를 가져 Linked List에 비해 속도가 느리며, resize 작업으로 메모리 공간이 낭비될 수 있다.

## Q. Lineked List는 어떤 자료구조인가?
> Linked List는 node라는 구조체로 이루어지고 node에는 데이터 값과 next node의 주소 데이터가 담겨서 node 끼리 연결된 형태의 자료구조이다.  
> 메모리상에 데이터가 불연속적으로 저장되지만 next node를 주소 데이터를 통해 찾아갈 수 있어서 논리적으로 연속성을 보장한다.  

- Linked List의 첫 node는 head라고 한다.

- Linked List의 마지막 node에는 next node의 주소 데이터 대신 null이 담긴다.

- Linked List의 삽입/삭제는 옮길 필요 없이 next node 주소 데이터만 변경하면 되므로 O(1)의 시간복잡도를 가진다.

- Linked List의 접근/탐색은 head node부터 순차적으로 접근해야 하므로 O(n)의 시간복잡도를 가진다.

## Q. Array와 Linked List를 비교하면?
> Array는 메모리상에 연속적으로 데이터를 저장하는 자료구조이고, Linked List는 메모리상에 불연속적으로 저장하지만 다음 메모리 주소 값을 저장하여 논리적 연속성을 보장한다.  
> Array의 경우 데이터 조회에 O(1), 삽입/삭제에 O(n)의 시간복잡도를 가지고, Linked List는 데이터 조회에 O(n), 삽입/삭제에 O(1)의 시간복잡도를 가진다.  
> 데이터 개수를 정확히 알고 조회를 자주한다면 Array, 데이터 개수를 정확히 모르고 삽입과 삭제를 자주한다면 Linked List를 사용하는 것이 유리하다.

- Array는 메모리상에 데이터를 연속적으로 저장하여, 저장된 데이터에 즉시 접근하는 random access가 가능하다. 시간복잡도는 O(1)이다.

- Array는 마지막 원소를 삽입/삭제하면 시간복잡도가 O(1)이지만, 중간 원소를 삽입/삭제하면 다른 원소를 옮겨야 하므로 시간복잡도가 O(n)이다.

- Array는 데이터 접근이 빠르지만, 선언 시 size를 설정하여 메모리를 할당하므로 데이터가 없어도 메모리를 차지하여 메모리가 낭비된다.

- Linked List는 메모리상에 데이터를 불연속적으로 저장하여, 저장된 특정 데이터에 접근하려면 순차 접근하는 sequential access를 해야한다.

- Linked List는 원소를 삽입/삭제 시에 next node를 가르키는 주소 데이터만 변경하면 되므로 시간복잡도가 O(1)이지만, 삽입/삭제하려는 위치에 접근하는 데에 O(n)이 걸리므로 결과적으로 삽입/삭제 시에 O(n)이 걸린다고 볼 수 있다.

- Linked List는 초기 size를 고민할 필요 없이, runtime 중에도 size를 변경할 수 있으며, 필요한 만큼 메모리를 할당하여 메모리의 낭비가 없다.

## Q. Array보다 Linked List를 사용하는 게 더 나은 상황은?
> 조회 작업이 적고, 삽입/삭제 작업을 자주하며, 데이터의 개수를 예측하기 힘들다면 Linked List가 더 유리하다.

## Q. Linked List보다 Array를 사용하는 게 더 나은 상황은?
> 조회 작업을 자주하고, 데이터의 개수가 명확하며, 메모리를 절약해야 한다면 Array가 더 유리하다.

## Q. Array와 Linked List의 메모리 할당은 언제 일어나고, 어느 영역을 할당 받는가?
> Array의 메모리 할당은 컴파일 단계에서 일어나며, Stack 영역에 할당된다.  
> Linked List의 메모리 할당은 런타임 단계에서 일어나며, Heap 영역에 할당된다.

## Q. Queue는 어떤 자료구조인가?
> Queue는 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO) 자료구조이다.  
> 캐시 구현, 프로세스 관리, 너비우선탐색(BFS) 알고리즘에서 자주 활용된다.

- Queue의 데이터는 First In First Out

- enqueue는 데이터를 추가하는 것, 맨 뒤에 데이터를 추가하므로 O(1)의 시간복잡도를 가진다.

- dequeue는 데이터를 추출하는 것, 맨 앞의 데이터를 추출하므로 O(1)의 시간복잡도를 가진다.

- Array-Based Queue의 경우 데이터 추가/추출 과정에서 남는 메모리가 생겨서 메모리가 낭비된다.

- List-Base Queue의 경우 재할당 혹은 메모리 낭비 걱정이 필요없다.

- deque는 queue의 개념을 확장한 자료구조로 양쪽에서 데이터 추가/추출이 가능하다.

- priority queue는 queue의 개념을 확장한 자료구조로 시간순서가 아니라 우선순위가 높은 순서이다.

- Queue의 활용 예시로는 하나의 자원을 공유하는 프린터, CPU task 스케줄링, 캐시 구현, BFS 알고리즘이 있다.

## Q. Stack은 어떤 자료구조인가?
> Stack은 가장 최근에 들어온 데이터가 먼저 나가는 후입선출(LIFO) 자료구조입니다. Stack에 데이터를 추가하는 push와 데이터를 꺼내는 pop 모두 O(1)의 시간 복잡도를 가집니다. Stack은 후위 표기법, 괄호 유효성 검사, 웹 브라우저의 방문기록, 깊이우선탐색(DFS) 알고리즘에서 자주 사용됩니다.

- Stack은 Queue와 비교 점과 사례들을 중점으로 숙지

- Stack은 Last In First Out

- push/pop의 시간복잡도는 O(1), top의 원소를 추가/삭제

- Stack은 재귀적인 특징이 있어서 재귀함수로도 구현 가능

## Q. Stack 2개를 이용한 Queue 구현 방법은?
> Stack 2개로 enqueue()와 dequeue()를 각각 나눠서 구현한다. enqueue()를 구현할 Stack은 push()를 이용하여 데이터를 저장시키고, dequeue()를 구현할 Stack에 enqueue()를 구현한 Stack의 모든 데이터를 pop() 시키고 다시 push()로 저장하여 top에 가장 처음 저장된 데이터가 먼저 오도록 한다. 그러면 Queue를 구현한 것과 같이 순서대로 pop() 시킬 수 있다.

- 시간복잡도는 enqueue()의 경우 O(1), dequeue()의 경우 비어있으면 채우고 진행하므로 O(n), 아니라면 O(1)이다.

## Q. Queue 2개를 이용한 Stack 구현 방법은?
> push 기능은 enqueue()를 이용하여 1번 Queue에 넣게 한다. pop 기능은 1번 Queue의 데이터가 하나 남을 때 까지 dequeue()하고 그 데이터들은 2번 Queue에 enqueue() 한다. 그리하면 가장 최근에 들어온 데이터만 1번 Queue에 남는다. 하나만 남은 데이터를 dequeue()하여 반환하면 pop이 완료된다. 그리고 다음 pop은 1번과 2번 Queue를 swap 시켜서 동작한다.

- 시간복잡도는 push()의 경우 O(1), pop()의 경우 O(n)이다.

## Q. Queue와 우선순위 큐 (priority queue)를 비교한다면?
> Queue 자료구조는 먼저 넣은 데이터가 먼저 나오는 선입선출의 형태를 가진다. 하지만 우선순위 큐는 들어간 순서가 아닌 우선순위가 높은 데이터가 먼저 나온다.

# 네트워크
## OSI 모델과 TCP/IP 모델 비교
OSI 모델은 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용의 7계층으로 이루어져 있다.
TCP/IP 모델은 네트워크 인터페이스, 인터넷, 전송, 응용의 4계층으로 이루어져 있다.
TCP/IP 모델은 OSI 모델보다 상대적으로 간단한 모델이라 실무에서 더 많이 사용된다.

이 모델들로 상대방에게 데이터를 전송하는 과정은 다음과 같다.
1. 송신자 측에서 데이터를 전송하려고 한다.
2. 전송하려는 데이터는 상위 계층에서 하위 계층으로 전달하면서 앞에 헤더가 붙이는 캡슐화를 진행한다.
3. 캡슐화 후 바이너리 데이터로 변환하여 상대방에게 송신한다.
4. 수신자 측에서 데이터를 수신하려고 한다.
5. 수신하려는 데이터는 하위 계층에서 상위 계층으로 전달하면서 앞의 헤더를 분해하는 역캡슐화를 진행한다.
6. 역캡슐화 후 데이터가 수신 완료된다.

## TCP 프로토콜
TCP 프로토콜은 신뢰성과 연결성을 제공하기 위한 프로토콜이다.
이를 위해 TCP는 오류제어, 흐름제어, 혼잡제어를 제공한다.
1. 오류제어 : 데이터 전송 중 손실, 중복, 손상된 세그먼트를 재전송하여 신뢰성을 유지한다.
2. 흐름제어 : 송수신자 간 데이터의 흐름을 조절하여 과도한 데이터 전송을 방지하고, 수신자가 처리할 수 있는 속도로 데이터를 전송한다.
3. 혼잡제어 : 네트워크 혼잡을 감지하고 조절하여 네트워크 안정성을 유지한다.

TCP 통신은 3단계의 과정을 거친다.
1. TCP 연결 초기화 -> 3-way handshake
2. 데이터 전송
3. TCP 연결 종료 -> 4-way handshake

## 3-way handshake
3-way handshake는 TCP 프로토콜로 통신하기 위해 연결을 초기화하는 과정이다.
3-way handshake 과정은 다음과 같다.
1. 클라이언트가 서버에게 연결을 요청하는 SYN 패킷을 보낸다.
2. SYN 패킷을 받은 서버가 클라이언트에게 연결 요청을 수락하는 SYN-ACK 패킷을 보낸다.
3. SYN-ACK 패킷을 받은 클라이언트가 연결이 성공했다고 알리기 위해 서버에게 ACK 패킷을 보낸다.
3-way handshake 과정은 연결의 신뢰성을 보장하기 위해 사용되고, 오류 제어 및 혼잡 제어와 관련이 있다.

## 4-way handshake
4-way handshake는 TCP 프로토콜로 통신을 마치면 그 연결을 종료시키는 과정이다.
4-way handshake 과정은 다음과 같다.
1. 클라이언트가 서버로 FIN 패킷을 보낸다.
2. 서버는 FIN 패킷을 받고 응답으로 ACK 패킷을 클라이언트로 보낸다.
3. 서버가 FIN 패킷을 보내면 클라이언트는 응답으로 ACK 패킷을 서버로 보낸다.
4. 서버가 ACK 패킷을 받으면 연결이 종료된다.

## HTTP (Hyper Text Transfer Protocol)
HTTP는 웹 상에서 정보를 주고받을 수 있는 통신 프로토콜이다.
특히, HTML 문서를 전송하는 데에 사용된다.
클라이언트는 HTTP request를 서버에 보내서 요청을 하고, 서버는 HTTP response를 클라이언트에 보내서 응답을 한다.
request는 스타트 라인, 헤더, 바디로 구성되며, 스타트 라인에는 메소드, 패스, HTTP 버전으로 구성된다.
response는 스테이터스 라인, 헤더, 바디로 수성되며, 스테이터스 라인에는 HTTP 버전, 스테이터스 코드, 스테이터스 메시지로 구성된다.
HTTP는 서버에 연결하고 요청에 대한 응답을 받으면 연결을 끊어버리는 Connectionless 특성을 가진다.
그래서 사용자가 많아도 동시 접속을 최소화시켜 더 많은 사용자의 요청을 처리할 수 있다.
하지만 연결을 끊어, 클라이언트의 이전 상태인 로그인 유무 등을 알 수 없는 Stateless 특성도 가진다.
이러한 단점을 해결하기 위해서 cookie, session, jwt가 도입한다.
HTTP는 text 정보를 주고받으므로 중간에 인터셉트하면 데이터 유출이 발생할 수 있다.
그래서 HTTP에 암호화를 추가한 프로토콜로 HTTPS가 생겼다.