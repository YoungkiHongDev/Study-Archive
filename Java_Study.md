# C언어와 Java의 차이점
**C언어**는 절차지향의 대표적인 언어로 이식성이 뛰어나다.
개발자가 메모리를 직접 관리해야 하지만 시스템 프로그래밍이 가능하다.
속도가 빨라서 운영체제나 임베디드 개발에 활용된다.
문제가 발생하면 순차적으로 수정해야하므로 유지보수가 어렵다.

**Java**는 객체지향의 대표적인 언어이다.
자바 가상 머신(JVM)을 이용해 다양한 운영체제에서 사용할 수 있는 독립성을 가진다.
가비지 컬렉션이 메모리를 자동으로 관리하여 개발자의 수고를 덜어준다.
다양한 분야에서 활용할 수 있지만 모바일과 웹 분야에 가장 많이 활용된다.
문제가 발생하면 문제가 되는 객체만 수정하면 되므로 유지보수가 용이하다.

# Java 버전
자바는 6개월마다 새로운 버전이 업데이트된다.
자바는 8 버전부터 LTS / Non-LTS 버전으로 나뉘어 릴리즈된다.
- **LTS** : 8년 동안 업데이트를 지원하는 버전이다.
- **Non-LTS** : 새로운 버전이 출시되면 더이상 업데이트를 지원하지 않는 버전이다.

# Java 특징
- **객체지향 언어**
- **분산처리 지원**
- **멀티스레드 지원**
- **OS 플랫폼 독립성**
- **가비지 컬렉션**

# Java 동작 방식
- **에디터**: 소스코드 Hello.java 작성
- **컴파일러**: Hello.java를 컴파일하여 Hello.class 산출
- **클래스로더**: 사용된 클래스들을 로딩해서 Hello.class 파일에 클래스들을 합침
- **바이트코드 검증기**: Hello.class 파일의 바이트코드를 검증
- **인터프리터**: 검증된 Hello.class를 한줄씩 번역

# JDK
자바 개발 도구를 말한다.
자바가 동작할 수 있는 실행환경과 자바 프로그램을 개발하는 도구가 들어있다.

# JVM
자바 가상 머신을 말한다.
바이트 코드 파일로 구성되는 자바 프로그램이다.
JVM이 운영체제에 맞춰 자바를 해석하여 다양한 운영체제에서 사용 가능하게 해준다.

# 객체지향 프로그래밍 OOP
**개념**
작은 문제들을 해결하는 객체를 만들고, 만든 객체들을 조합하여 큰 문제를 해결하는 Bottom-UP 방식의 프로그래밍이다.

**장점**
- 코드의 재사용성이 높아진다.
- 유지보수가 쉬워진다.
- 코드가 간결해진다.

**단점**
- 처리 시간이 비교적 오래 걸린다.
- 프로그램 설계 시 많은 시간을 투자해야한다.

# OOP의 4가지 특징
**1. 캡슐화**
유사한 속성과 메소드를 하나의 클래스로 모은것을 캡슐화라고 한다.
로직이나 변수를 감추고 API만 외부에 제공하는 정보 은닉이 가능하다.

**2. 상속**
자식 클래스가 부모 클래스의 멤버 변수나 메소드를 사용 가능하도록 하는 것을 상속이라고 한다.
상속을 이용하면 클래스의 재사용이 용이하다.

**3. 추상화**
클래스들의 공통적인 메소드들을 인터페이스로 정의하는 것을 추상화라고 한다.

**4. 다형성**
자신의 서브클래스에서 생성한 인스턴스도 클래스 변수에 대입할 수 있는 것을 다형성이라고 한다.
같은 이름의 메소드가 상황에 따라 다르게 동작하게 할 수 있다.
다형성을 이용하는 방법으로 오버로딩과 오버라이딩이 있다.

# 정적 필드/메소드
인스턴스를 생성하지 않고 클래스 자체에서 사용되는 변수나 메소드이다.
변수나 메소드 앞에 **static** 키워드를 붙여서 만든다.
정적 필드는 인스턴스 없이 **클래스명.변수명** 으로 호출해서 사용이 가능하다.
정적 메소드는 인스턴스 없이 **클래스명.메소드명()** 으로 호출해서 사용이 가능하다.
상수 필드는 **final static** 키워드를 붙이고 변수명을 대문자로 구성한다.
정적 메소드의 대표적인 예로 java.lang.Math 클래스에서 제곱을 구하는 pow() 같은 경우가 있다.

# 상속 inheritance
기존 클래스가 가지고 있는 것을 그대로 물려받으면서 필요한 필드나 메소드를 추가로 정의하는 것이다.
상속을 받은 서브클래스는 클래스명 뒤에 **extends** 키워드와 상속을 하는슈퍼클래스 명을 명시한다.
만약에 **final** 키워드를 사용하면 상속이 금지된다.

# 오버로딩
클래스 내에서 메소드의 이름은 같지만 매개변수의 개수나 타입을 달리해서 사용하는 것을 오버로딩이라고 한다.
메소드 네이밍을 해야하는 개발자의 고민을 덜어준다.
클래스 내에서 메소드의 이름이 같아도 파라미터의 개수나 데이터형만 다르면 어러 개를 선언할 수 있다.
대표적인 예로 생성자의 파라미터를 다르게 해서 만드는 경우가 있다.

# 오버라이딩
부모 클래스의 메소드를 자식 클래스에서 용도에 맞게 재정의하는 것을 오버라이딩이라고 한다.
오버로딩과 다르게 매개변수가 동일해야 한다.
슈퍼 클래스의 메소드와 같거나 넓은 범위의 접근 제어자만 사용 가능하다.
슈퍼 클래스에 있는 메소드와 같은 이름의 메소드를 서브 클래스에서 재정의 하는 것이다.
슈퍼 클래스의 메소드를 호출할 경우 **super.메소드명()**으로 호출한다.

# 추상 클래스/메소드 abstract
추상 클래스는 인스턴스화를 금지하는 클래스이다.
클래스 앞에 **abstract** 키워드를 사용하면 추상 클래스로 지정된다.

추상 메소드는 메소드 본체가 없는 메소드이다.
메소드 앞에 **abstract** 키워드를 사용하면 추상 메소드로 지정된다.
추상 메소드를 포함하는 클래스는 추상 클래스로 지정해야한다.
추상 메소드는 **{ }** 괄호를 쓰지 않는다.

사용 목적은 공통적으로 사용되는 기능을 추상 메소드로 선언해놓고 추상 클래스를 상속받은 후 추상 메소드를 오버라이딩해서 사용하기 위함이다.

# 인터페이스 interface
**class** 키워드 대신에 **interface** 키워드를 사용한다.
내부에는 추상 메소드를 선언한다.
인터페이스를 상속받을 때 extends 키워드가 아니라 implements 키워드를 사용한다.
Java는 다중 상속을 지원하지 않지만 인터페이스로 비슷하게 작성할 수 있다.
Ex) public class A extends B implements C

# 익명 내부 클래스
이름이 없는 내부 클래스를 말한다.
주로 한번만 사용하고 버려지는 클래스에 사용한다.

# 접근제어자
OOP 특징 중 캡슐화와 관련된다.
클래스 내부의 변수나 메소드의 사용 범위를 결정한다.
사용목적은 클래스 내부 정보를 외부에서 접근하지 못하게하여 결합도를 낮추기 위함이다.

> 접근제어자의 종류
- **private**: 내부에서 접근 가능
- **default**: 패키지 안에서 접근 가능
- **protected**: 패키지 안과 외부에서 상속받은 경우 접근 가능
- **public**: 항상 접근이 가능

# 생성자 Constructor
클래스명과 동일한 이름을 가진 메소드이다.
리턴 타입을 정의하지 않는다.
객체가 생성될 때 자동으로 호출된다.
그래서 new 키워드가 사용될 때 호출된다.
만약, 생성자를 구현하지 않으면 컴파일러가 기본 생성자(디폴트 생성자)를 추가한다.
메소드를 오버로딩하는 것처럼 생성자도 오버로딩 할 수 있다.

# 람다 함수
자바 8버전부터 사용할 수 있다.
익명 함수를 지칭하는 용어로 함수를 보다 단순하게 표현할 수 있다.

> 람다의 특징
- 이름이 없는 익명 함수
- 파라미터가 있는 함수는 괄호 안에 지정하여 사용

> 람다식의 장점
- 코드의 라인수가 줄어든다. (불필요한 코드를 제거)
- 병렬 프로그래밍이 가능하다.
- 람다식으로 실행문을 바로 전달할 수 있다.
- 가독성이 높아진다.

> 람다식의 단점
- 재사용이 불가능하다. (일회용 함수 정의가 목적)
- 불필요하게 남발하면 가독성이 떨어진다. (같은 기능의 함수를 여러번 정의하는 상황이 발생할수도)

> 람다식의 표현
- 화살표를 사용한다.
- Ex) (매개변수) -> {함수 구현부} 또는 () -> {함수 구현}
- 작성할 실행문이 한줄이면 괄호를 생략 가능하다.
- 하지만 리턴문이라면 생략할 수 없다.

# System.out.println()은 무엇인가?
JAVA에서 콘솔창에 변수나 문자열을 출력하는 명령어이다.
public static final void printstream out; 을 가르키는 코드이다.
시스템 클래스가 초기화되면서 이 정적변수에 객체가 대입된다.
대입되기 전까지의 out은 참조타입만 가진 NULL이며, 이것은 하나의 static 객체로 재정의 된다.
즉, printstream의 객체를 정적변수 out에 넣어서 static 객체로 만든 것이다.
그래서 System.out이 가능하게 되고 이것은 클래스처럼 보이지만 이 자체로 하나의 객체라고도 볼 수 있다.
요약하자면 System.out은 간접 참조와 같고 다른 언어에서 import나 메소드를 찾아가는 과정과 매우 비슷하다.

# 자바 ArrayList와 비교한 Array의 장점
데이터의 크기를 미리 정해야하고 추가 및 삭제가 필요치 않을 경우 ArrayList보다는 Array가 유리하다.
문법적으로 ArrayList보다 Array가 구현하기가 쉽다.
Array를 생성 시 메모리가 미리 할당되어 연속된 메모리 공간에 위치하므로 메모리 관리가 용이하다.
메모리 공간에 위와 같은 장점이 있어서 데이터를 읽는 속도가 빠르다.

# Enum
예를들어, int형 변수에 0~6이라는 정해진 값만 할당하고 싶은데 int형은 0~6 뿐만 아니라 다른 숫자도 할당이 가능했다.  
그래서 이러한 문제점을 타입에 안전하지 않은 No Type-Safety라고 불렀으며, 이를 해결하기 위해 Enum이 등장했다.  
사용 방법은 class 키워드 대신에 enum을 넣고 생성할 수 있다.  

```Java
public enum Day {
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}
```

Day enum 안에 상수로 넣을 값을 넣으면, Day는 오직 안에 들어가있는 값만 할당된다.  

Enum 타입의 특징을 정리하면 다음과 같다.  
- Enum은 타입에 대해 안전하다. (Type-Safety)
- 미리 정의된 Enum 변수 안의 상수만 대입할 수 있다.
- Enum은 switch문에서 사용이 가능하다. (switch문에서 String을 사용할 수 있는 JDK 7이상일 때)