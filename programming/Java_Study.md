# C언어와 Java의 차이점
`C언어`는 절차지향 언어로, 메모리를 직접 관리하고 시스템 프로그래밍에 적합하다.  
속도가 빠르며 이식성이 뛰어나지만, 문제가 발생하면 순차적으로 수정해야 하므로 유지보수가 어렵다.

`Java`는 객체지향 언어로, 자바 가상 머신(JVM)을 통해 다양한 운영체제에서 독립적으로 실행된다.  
가비지 컬렉션으로 메모리를 자동으로 관리하며, 모바일과 웹 분야에서 주로 사용된다.  
유지보수가 용이하며, 이유는 다음과 같다.
- **객체지향 프로그래밍**: 코드의 모듈화, 재사용, 유연성을 제공
- **가비지 컬렉션**: 자동 메모리 관리로 메모리 누수 문제 감소
- **표준 라이브러리**: 공통 기능을 내장 라이브러리로 제공하여 개발 효율성 증가
- **강력한 예외 처리**: 오류를 명확하게 처리하고 추적 가능


# Java 버전
자바는 6개월마다 새로운 버전이 업데이트된다.  
자바 9 버전부터는 `LTS` (장기 지원) 버전과 `Non-LTS` (비장기 지원) 버전으로 나뉘어 릴리즈된다.
- **LTS** : 8년 동안 업데이트를 지원하는 버전
- **Non-LTS** : 새로운 버전이 출시되면 더이상 업데이트를 지원하지 않는 버전


# Java 동작 방식
- **에디터**: 소스코드 작성 (Hello.java)
- **컴파일러**: 소스코드를 컴파일하여 바이트코드 생성 (Hello.class)
- **클래스로더**: Hello.class 파일에 정의된 클래스들을 로딩
- **바이트코드 검증기**: 바이트코드를 검증
- **인터프리터**: 바이트코드를 실행


# JDK
자바 개발 도구로, 자바 실행환경과 개발 도구를 포함한다.


# JVM
자바 가상 머신으로, 바이트코드 파일을 해석하여 다양한 운영체제에서 실행 가능하게 한다.


# 객체지향 프로그래밍 (OOP)
문제를 해결하는 객체를 만들고 조합하여 큰 문제를 해결하는 Bottom-Up 방식의 프로그래밍

**장점**
- 코드 재사용성 증가
- 유지보수 용이
- 코드 간결화

**단점**
- 처리 시간이 길어질 수 있음
- 설계에 많은 시간 필요


# OOP의 4가지 특징
1. **캡슐화**: 속성과 메소드를 클래스로 모아 정보 은닉
2. **상속**: 자식 클래스가 부모 클래스의 멤버를 상속받아 재사용
3. **추상화**: 공통 메소드를 인터페이스로 정의
4. **다형성**: 서브클래스 인스턴스를 클래스 변수에 대입 가능, 메소드 오버로딩과 오버라이딩


# 정적 필드/메소드
- **정적 필드**: 클래스에서 직접 접근 가능 (`클래스명.변수명`)
- **정적 메소드**: 클래스에서 직접 호출 가능 (`클래스명.메소드명()`)
- **상수 필드**: `final static` 키워드 사용, 변수명은 대문자로 사용


# 상속 (Inheritance)
기존 클래스의 필드와 메소드를 상속받아 추가적인 필드와 메소드를 정의할 수 있다.  
`extends` 키워드를 사용하며, `final` 키워드로 상속을 금지할 수 있다.


# 오버로딩
클래스 내에서 메소드 이름이 같지만 매개변수 개수나 타입이 다른 메소드 정의를 의미한다.


# 오버라이딩
부모 클래스의 메소드를 자식 클래스에서 재정의하는 방식이다.  
매개변수가 동일해야 하며, 접근 제어자는 부모 클래스의 메소드와 같거나 넓은 범위로 설정해야 한다.  
`super.메소드명()`으로 부모 클래스 메소드를 호출한다.


# 추상 클래스/메소드 (Abstract)
- **추상 클래스**: 인스턴스화 금지, `abstract` 키워드 사용
- **추상 메소드**: 본체를 가지지 않고 선언만 하는 메소드, `abstract` 키워드 사용


# 인터페이스 (Interface)
- **interface** 키워드 사용
- 내부에 추상 메소드 선언
- `implements` 키워드로 상속
- 클래스를 통한 다중 상속을 지원하지 않지만, 인터페이스를 통해 유사하게 사용 가능


# 접근제어자
- **private**: 클래스 내부에서만 접근
- **default**: 패키지 내에서 접근
- **protected**: 패키지 및 상속받은 클래스에서 접근
- **public**: 모든 곳에서 접근


# 생성자 (Constructor)
- 클래스명과 동일한 메소드
- 리턴 타입 없음
- 객체 생성 시 자동 호출
- 기본 생성자가 자동으로 추가되며, 오버로딩 가능


# Enum
정해진 상수만을 할당할 수 있는 타입이다.

## Enum 타입 특징
- 타입 안전 (Type-Safety)
- 미리 정의된 상수만 대입 가능
- switch문에서 사용 가능


# 람다 함수
람다 함수는 자바 8부터 지원되는 기능으로, 익명 함수(이름이 없는 함수)를 간단하게 표현할 수 있는 방법이다.  
람다 함수를 사용하면 코드의 가독성과 간결성이 향상된다.

## 람다의 특징
- **익명 함수**: 람다 함수는 이름이 없다.
- **간결한 표현**: 코드 라인이 감소하고 가독성이 향상된다.
- **함수형 프로그래밍 지원**: 람다 함수는 함수형 프로그래밍을 지원한다.

## 람다식 표현
람다식은 `(매개변수) -> {함수 구현부}` 형태로 작성한다.
- 매개변수가 하나인 경우 소괄호 생략가능
- 실행문이 하나인 경우 중괄호 생략가능

```java
// 매개변수가 하나인 경우
a -> a * 2

// 매개변수가 여러 개인 경우
(x, y) -> x + y

// 실행문이 여러 개인 경우
(x, y) -> {
    int result = x + y;
    return result;
}
```

## 람다식 사용 조건
람다식은 오직 함수형 인터페이스에서만 사용 가능하다.  
함수형 인터페이스는 단 하나의 추상 메소드를 가지는 인터페이스를 의미한다.  
`@FunctionalInterface` 어노테이션을 사용하여 함수형 인터페이스라고 명시할 수 있다.

```java
@FunctionalInterface
public interface Calculable {
    void calculate(int x, int y);
}
```

## 람다식 사용 예제
익명 구현 객체를 람다식으로 변환하는 예제.

```java
// 익명 구현 객체
Calculable calc = new Calculable() {
    @Override
    public void calculate(int x, int y) {
        System.out.println(x + y);
    }
};

// 람다식
Calculable calcLambda = (x, y) -> System.out.println(x + y);

// 람다식 사용
calcLambda.calculate(10, 20);  // 출력: 30

```


# 스트림 Stream
자바 8에서 추가된 기능으로, 배열이나 컬렉션 인터페이스를 조합하여 원하는 결과를 얻을 수 있다.

## 스트림의 특징
- 함수형 프로그래밍 지원
- 병렬 처리 용이

## 스트림 생성 방법
1. 컬렉션 스트림
2. 기본 타입형 스트림
3. 문자열 스트림
4. 병렬 스트림
5. Stream.builder()
6. Stream.generate()
7. Stream.iterate()