> 기출로 대비하는 개발자 전공면접 [CS 완전정복]  
> https://inf.run/M1LW

# 자료구조
## Q. Array는 어떤 자료구조인가?
> Array는 데이터를 메모리상에 연속적으로 미리 할당된 크기만큼 저장하는 자료구조이다.

- Array 질문은 Linked List 질문과 연계 될 수 있다. 따라서 메모리 저장 방식과 연산 속도 등 차이점을 알아놓는 것이 좋다.

- Array는 데이터가 메모리에 연속적으로 저장된다.

- 조회 시 메모리에 연속적으로 저장된다는 점을 이용하여 첫번째 데이터의 주소에서 더하기 연산으로 원하는 데이터 주소에 바로 찾아가므로 조회는 O(1)이 걸리며, 이것을 random access라고 한다.

- 삽입/삭제 시 마지막 인덱스라면 O(1), 아니라면 삽입 시에는 요소들을 뒤로 밀고 삭제 시에는 요소들을 앞으로 당겨야하므로 O(n)이 걸린다.

- 탐색 시 일일이 인덱스들을 방문하여 탐색하므로 O(n)이 걸린다.
- Array 장점은 조회에 O(1) 밖에 안걸리므로 조회를 자주 해야할 경우에 유리하다.

- Array 단점은 크기를 미리 정해야하므로 메모리가 낭비될 수 있고, 크기가 부족해서 새로운 Array로 데이터를 이동시키면서 오버헤드가 발생할 수 있다.

## Q. 데이터가 많아서 Array의 size를 넘을 경우 해결방법은?
> size를 예측할 수 있으면 기존보다 size가 더 큰 Array를 만들고 데이터를 옮긴다.  
> size를 예측할 수 없으면 Array 대신 Linked List를 사용하여 데이터가 추가될 때마다 메모리 공간을 할당하여 저장한다.

## Q. Dynamic Array는 어떤 자료구조인가?
> Array는 고정된 size보다 많은 수의 데이터를 저장할 수 없다.  
> 이를 위해 Dynamic Array를 사용할 수 있다.  
> Dynamic Array는 Array의 한계점을 보완한 자료구조이다.  
> 메모리가 초과되면 resize를 통해 데이터를 더 저장할 수 있도록 size를 조절할 수 있어 size를 고민할 필요가 없다는 장점이 있다.  
> resize의 대표적인 방법으로 기존의 2배 size로 조절하는 Doubling이 있다.

- Array의 특징인 고정된 사이즈의 한계점을 보완한 자료구조이다.

- Dynamic Array는 사이즈를 고민할 필요가 없다는 장점이 있다.

- Dynamic Array의 특징으로 첫번째는 resize, 두번째는 Array와 달리 데이터 추가 시 다른 시간복잡도를 가질 수 있다는 점이다.

- Dynamic Array는 resize를 위해 저장공간이 가득 차면 기존의 배열보다 더 큰 배열을 생성하여 데이터를 옮긴다.

- resize의 대표적인 방법인 Doubling은 메모리에 여유가 있을 때 데이터를 추가할 경우 O(1)이지만, 메모리를 초과하면 기존의 2배가 되는 배열을 생성하고 데이터를 일일이 옮기므로 O(n)이 된다.

- 데이터 추가 시 대부분 작업은 O(1), resize할 때만 O(n)이므로 전체적으로 O(1)이라고 할 수 있다.

## Q. Dynamic Array와 Linked List를 비교한 장단점은?
> Linked List와 비교하여 Dynamic Array의 장점은 데이터에 접근 시 random access를 이용하므로 O(1)의 시간복잡도를 가지고, 맨 뒤에 데이터를 추가하거나 삭제할 때도 O(1)의 시간복잡도를 가져서 Linked List에 비해 속도가 빠르다.  
> 하지만, 앞이나 중간에 데이터를 추가하면 연속적으로 저장된 데이터를 뒤로 한칸씩 옮겨야하므로 O(n)의 시간복잡도를 가져 Linked List에 비해 속도가 느리며, resize 작업으로 메모리 공간이 낭비될 수 있다.

## Q. Lineked List는 어떤 자료구조인가?
> Linked List는 node라는 구조체로 이루어지고 node에는 데이터 값과 next node의 주소 데이터가 담겨서 node 끼리 연결된 형태의 자료구조이다.  
> 메모리상에 데이터가 불연속적으로 저장되지만 next node를 주소 데이터를 통해 찾아갈 수 있어서 논리적으로 연속성을 보장한다.  

- Linked List의 첫 node는 head라고 한다.

- Linked List의 마지막 node에는 next node의 주소 데이터 대신 null이 담긴다.

- Linked List의 삽입/삭제는 옮길 필요 없이 next node 주소 데이터만 변경하면 되므로 O(1)의 시간복잡도를 가진다.

- Linked List의 접근/탐색은 head node부터 순차적으로 접근해야 하므로 O(n)의 시간복잡도를 가진다.

## Q. Array와 Linked List를 비교하면?
> Array는 메모리상에 연속적으로 데이터를 저장하는 자료구조이고, Linked List는 메모리상에 불연속적으로 저장하지만 다음 메모리 주소 값을 저장하여 논리적 연속성을 보장한다.  
> Array의 경우 데이터 조회에 O(1), 삽입/삭제에 O(n)의 시간복잡도를 가지고, Linked List는 데이터 조회에 O(n), 삽입/삭제에 O(1)의 시간복잡도를 가진다.  
> 데이터 개수를 정확히 알고 조회를 자주한다면 Array, 데이터 개수를 정확히 모르고 삽입과 삭제를 자주한다면 Linked List를 사용하는 것이 유리하다.

- Array는 메모리상에 데이터를 연속적으로 저장하여, 저장된 데이터에 즉시 접근하는 random access가 가능하다. 시간복잡도는 O(1)이다.

- Array는 마지막 원소를 삽입/삭제하면 시간복잡도가 O(1)이지만, 중간 원소를 삽입/삭제하면 다른 원소를 옮겨야 하므로 시간복잡도가 O(n)이다.

- Array는 데이터 접근이 빠르지만, 선언 시 size를 설정하여 메모리를 할당하므로 데이터가 없어도 메모리를 차지하여 메모리가 낭비된다.

- Linked List는 메모리상에 데이터를 불연속적으로 저장하여, 저장된 특정 데이터에 접근하려면 순차 접근하는 sequential access를 해야한다.

- Linked List는 원소를 삽입/삭제 시에 next node를 가르키는 주소 데이터만 변경하면 되므로 시간복잡도가 O(1)이지만, 삽입/삭제하려는 위치에 접근하는 데에 O(n)이 걸리므로 결과적으로 삽입/삭제 시에 O(n)이 걸린다고 볼 수 있다.

- Linked List는 초기 size를 고민할 필요 없이, runtime 중에도 size를 변경할 수 있으며, 필요한 만큼 메모리를 할당하여 메모리의 낭비가 없다.

## Q. Array보다 Linked List를 사용하는 게 더 나은 상황은?
> 조회 작업이 적고, 삽입/삭제 작업을 자주하며, 데이터의 개수를 예측하기 힘들다면 Linked List가 더 유리하다.

## Q. Linked List보다 Array를 사용하는 게 더 나은 상황은?
> 조회 작업을 자주하고, 데이터의 개수가 명확하며, 메모리를 절약해야 한다면 Array가 더 유리하다.

## Q. Array와 Linked List의 메모리 할당은 언제 일어나고, 어느 영역을 할당 받는가?
> Array의 메모리 할당은 컴파일 단계에서 일어나며, Stack 영역에 할당된다.  
> Linked List의 메모리 할당은 런타임 단계에서 일어나며, Heap 영역에 할당된다.

## Q. Queue는 어떤 자료구조인가?
> Queue는 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO) 자료구조이다.  
> 캐시 구현, 프로세스 관리, BFS 알고리즘에서 자주 활용된다.

- Queue의 데이터는 First In First Out

- enqueue는 데이터를 추가하는 것, 맨 뒤에 데이터를 추가하므로 O(1)의 시간복잡도를 가진다.

- dequeue는 데이터를 추출하는 것, 맨 앞의 데이터를 추출하므로 O(1)의 시간복잡도를 가진다.

- Array-Based Queue의 경우 데이터 추가/추출 과정에서 남는 메모리가 생겨서 메모리가 낭비된다.

- List-Base Queue의 경우 재할당 혹은 메모리 낭비 걱정이 필요없다.

- deque는 queue의 개념을 확장한 자료구조로 양쪽에서 데이터 추가/추출이 가능하다.

- priority queue는 queue의 개념을 확장한 자료구조로 시간순서가 아니라 우선순위가 높은 순서이다.

- Queue의 활용 예시로는 하나의 자원을 공유하는 프린터, CPU task 스케줄링, 캐시 구현, BFS 알고리즘이 있다.


# 운영체제
# 데이터베이스
# 네트워크